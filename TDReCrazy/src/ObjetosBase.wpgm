import wollok.game.*

class ObjetoEnPantalla {
	var property posicion
	
	method agregarAPantalla() {
		game.addVisual(self)
	}
	
	method quitarDePantalla() {
		game.removeVisual(self)
	}
}

//el nombre no esta fijo
object system {
	const property camino = [] //Contiene una lista con las posiciones de los caminos
	/**
	 *
	 * Esta propiedad decidi ponerla luego de pensar las diferentes formas de recorrer el camino
	 * para hacer avanzar a las unidades y pense que esta seria la mas sensilla
	 *
	 **/ 
	var property torres = [] //Contiene una lista con todas las torres
	//La idea es tener una lista con todas las torres para poder hacer que ataquen al final del turno
	
	method agregar(torre) {
		torres.add(torre)
	}
	method quitar(torre) {
		torres.remove(torre)
	} 
}

object jugador {
	var property oro
	var property hp
	
	method ganarOro(cant) {
		oro += cant
	}
	
	method perderOro(cant) {
		oro -= cant
	}
	
	method aumentarHp(cant) {
		hp += cant
	}
	
	method perderHp(cant) {
		hp -= cant	
	}
}

object cabezal inherits ObjetoEnPantalla{
	
	override method agregarAPantalla() {
		game.addVisualCharacter(self)
	}
	
	method sePuedeConstruir() {
		return true
	}
}

class Torre inherits ObjetoEnPantalla {
	const property atk
	const property range
	const property pierce
	const property cost
	
	const property player = jugador
	const property sistem = system
	const property cabe = cabezal
	
	method atacar() {
		
	}
	
	method vender() {
		player.ganarOro(cost/3)
		self.quitarDePantalla()
		sistem.quitar(self)
	}
	
	method construir() {
		if (cost <= player.oro() && cabe.sePuedeConstruir()) {
			player.perderOro(cost)
			self.posicion(cabe.posicion())
			sistem.agregar(self)
			self.agregarAPantalla()
		}
	}
}
class Mina inherits Torre{ 
    override method atacar(){
    	//cuando un enemigo colisione con la mina se activa, habria que usar el whenColliderDo no?
    	self.desaparecerDelMapa()
    }
    method desaparecerDelMapa(){
    	self.quitarDePantalla()
    }
}
class TorreLenta inherits ObjetoEnPantalla{//esta torre tiene mucho daÃ±o pero puede lanzar un disparo cada cierto tiempo 
	const property range
	const property cost
	
	const property player = jugador
	const property sistem = system
	const property cabe = cabezal
	method atk(){
		return 9999
	}
	method pierce(){
		return 1
	}
	method atacar() {
		//cada x (x es mayor que el tiempo de las demas torres) segundos disparaa
	}
	
	method vender() {
		player.ganarOro(cost/3)
		self.quitarDePantalla()
		sistem.quitar(self)
	}
	
	method construir() {
		if (cost <= player.oro() && cabe.sePuedeConstruir()) {
			player.perderOro(cost)
			self.posicion(cabe.posicion())
			sistem.agregar(self)
			self.agregarAPantalla()
		}
	}
}


class Enemy inherits ObjetoEnPantalla {
	const property atk
	const property maxHp
	var   property vida
	const property recompenza
	const property speed
	
	const property player = jugador
	
	method atacar() {
		player.perderHp(atk)
		self.quitarDePantalla()
	}
	
	method morir() {
		player.ganarOro(recompenza)
		self.quitarDePantalla()
	}
	
	method perderVida(cant) {
		if (cant >= vida) {
			self.morir()
		} else {
			vida -= cant
		}
	}
	
	method ganarVida(cant) { //hice este metodo por si nos pinta hacer unidades enemigas que puedan curar
		if (vida+cant >= maxHp) {
			vida = maxHp
		} else {
			vida += cant
		}
	}
	
	method avanzar() {
		/**
		 *
		 * Avanza tantos casilleros del camino como diga su velocidad
		 *
		 */
	}
}